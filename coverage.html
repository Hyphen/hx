
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Hyphen/cli/cmd/auth/auth.go (0.0%)</option>
				
				<option value="file1">github.com/Hyphen/cli/cmd/root.go (0.0%)</option>
				
				<option value="file2">github.com/Hyphen/cli/cmd/update/update.go (63.2%)</option>
				
				<option value="file3">github.com/Hyphen/cli/cmd/version/version.go (0.0%)</option>
				
				<option value="file4">github.com/Hyphen/cli/config/config.go (82.4%)</option>
				
				<option value="file5">github.com/Hyphen/cli/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "fmt"

        "github.com/Hyphen/cli/config"
        "github.com/spf13/cobra"
)

// AuthCmd represents the auth command
var AuthCmd = &amp;cobra.Command{
        Use:   "auth",
        Short: "Authenticate with the server",
        Long: `Authenticate allows users to start a session with the server
by providing credentials.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                login()
        }</span>,
}

func login() <span class="cov0" title="0">{
        var username, password string
        fmt.Print("Enter Username: ")
        fmt.Scanln(&amp;username)
        fmt.Print("Enter Password: ")
        fmt.Scanln(&amp;password)

        config.SaveCredentials(username, password)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/Hyphen/cli/cmd/auth"
        "github.com/Hyphen/cli/cmd/update"
        "github.com/Hyphen/cli/cmd/version"
        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:   "hyphen",
        Short: "cli for hyphen",
        Long:  `hypen is a cli for ...`,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(auth.AuthCmd)
        rootCmd.AddCommand(version.VersionCmd)
        rootCmd.AddCommand(update.UpdateCmd)
}</span>

func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package update

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/spf13/cobra"
)

// Service interfaces for dependency injection
type HTTPClient interface {
        Get(url string) (*http.Response, error)
}

type FileHandler interface {
        CreateTemp(dir, pattern string) (*os.File, error)
        WriteFile(filename string, data []byte, perm os.FileMode) error
        Chmod(name string, mode os.FileMode) error
        Rename(oldpath, newpath string) error
}

// Default implementations
type DefaultHTTPClient struct{}
type DefaultFileHandler struct{}

func (d DefaultHTTPClient) Get(url string) (*http.Response, error) <span class="cov0" title="0">{
        return http.Get(url)
}</span>

func (d DefaultFileHandler) CreateTemp(dir, pattern string) (*os.File, error) <span class="cov0" title="0">{
        return os.CreateTemp(dir, pattern)
}</span>

func (d DefaultFileHandler) WriteFile(filename string, data []byte, perm os.FileMode) error <span class="cov0" title="0">{
        return os.WriteFile(filename, data, perm)
}</span>

func (d DefaultFileHandler) Chmod(name string, mode os.FileMode) error <span class="cov0" title="0">{
        return os.Chmod(name, mode)
}</span>

func (d DefaultFileHandler) Rename(oldpath, newpath string) error <span class="cov0" title="0">{
        return os.Rename(oldpath, newpath)
}</span>

// CommandRunner is a function type for running commands, to facilitate mocking in tests
type CommandRunner func(name string, arg ...string) *exec.Cmd

// Config struct for dependencies and settings
type Updater struct {
        Version           string
        URLTemplate       string
        HTTPClient        HTTPClient
        FileHandler       FileHandler
        GetExecPath       func() string
        DetectPlatform    func() string
        DownloadAndUpdate func(url string) error
        CommandRunner     CommandRunner
}

const (
        linux    = "linux"
        macos    = "macos"
        macosArm = "macos-arm"
        windows  = "windows"
)

var validOs = []string{linux, macos, macosArm, windows}

var UpdateCmd = &amp;cobra.Command{
        Use:   "update",
        Short: "Update the Hyphen CLI",
        Long:  `This command updates the Hyphen CLI to the specified version or the latest version available for your operating system`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                updater := NewDefaultUpdater(version)
                updater.Run(cmd, args)
        }</span>,
}

func NewDefaultUpdater(version string) *Updater <span class="cov8" title="1">{
        defaultUrlTemplate := "http://localhost:4000/api/downloads/hyphen-cli/%s?os=%s"
        updater := &amp;Updater{
                Version:           version,
                URLTemplate:       defaultUrlTemplate,
                HTTPClient:        DefaultHTTPClient{},
                FileHandler:       DefaultFileHandler{},
                GetExecPath:       defaultGetExecutablePath,
                DetectPlatform:    defaultDetectPlatform,
                DownloadAndUpdate: nil,
                CommandRunner:     exec.Command, // Use exec.Command by default
        }
        updater.DownloadAndUpdate = updater.downloadAndUpdate // Initialize the function reference.
        return updater
}</span>

func (u *Updater) Run(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
        osType := u.DetectPlatform()
        if !isValidOs(osType) </span><span class="cov8" title="1">{
                fmt.Printf("Unsupported operating system: %s\n", osType)
                return
        }</span>

        <span class="cov8" title="1">targetVersion := getTargetVersion(u.Version)
        updateUrl := fmt.Sprintf(u.URLTemplate, targetVersion, osType)
        err := u.DownloadAndUpdate(updateUrl)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Failed to update Hyphen CLI: %v\n", err)
                return
        }</span>
        <span class="cov8" title="1">fmt.Println("Hyphen CLI updated successfully")</span>
}

func defaultDetectPlatform() string <span class="cov0" title="0">{
        switch runtime.GOOS </span>{
        case "linux":<span class="cov0" title="0">
                return linux</span>
        case "darwin":<span class="cov0" title="0">
                if runtime.GOARCH == "arm64" </span><span class="cov0" title="0">{
                        return macosArm
                }</span>
                <span class="cov0" title="0">return macos</span>
        case "windows":<span class="cov0" title="0">
                return windows</span>
        default:<span class="cov0" title="0">
                return runtime.GOOS</span>
        }
}

func isValidOs(osType string) bool <span class="cov8" title="1">{
        for _, valid := range validOs </span><span class="cov8" title="1">{
                if osType == valid </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func getTargetVersion(version string) string <span class="cov8" title="1">{
        if strings.TrimSpace(version) == "" </span><span class="cov0" title="0">{
                return "latest"
        }</span>
        <span class="cov8" title="1">return version</span>
}

func (u *Updater) downloadAndUpdate(url string) error <span class="cov8" title="1">{
        resp, err := u.HTTPClient.Get(url)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error fetching the update: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download update, status code: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">filename := "hyphen"
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                filename += ".exe"
        }</span>

        <span class="cov8" title="1">tempFile, err := u.FileHandler.CreateTemp("", filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating temp file: %w", err)
        }</span>
        <span class="cov8" title="1">defer tempFile.Close()

        _, err = io.Copy(tempFile, resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing to temp file: %w", err)
        }</span>

        <span class="cov8" title="1">if runtime.GOOS != "windows" </span><span class="cov8" title="1">{
                if err := u.FileHandler.Chmod(tempFile.Name(), 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error setting executable permission: %w", err)
                }</span>
                <span class="cov8" title="1">return u.moveToExecutablePath(tempFile.Name())</span>
        }

        <span class="cov0" title="0">return u.scheduleWindowsUpdate(tempFile.Name())</span>
}

func (u *Updater) scheduleWindowsUpdate(tempFileName string) error <span class="cov8" title="1">{
        executablePath := u.GetExecPath()
        batchScript := `
@echo off
echo Updating Hyphen CLI...
ping 127.0.0.1 -n 5 &gt; nul
move /Y "%s" "%s"
if %%errorlevel%% neq 0 (
    echo Failed to move updated file.
    exit /b %%errorlevel%%
) else (
    echo Successfully moved updated file.
)
`
        scriptContent := fmt.Sprintf(batchScript, tempFileName, executablePath)
        scriptPath := filepath.Join(os.TempDir(), "update_hyphen.bat")

        if err := u.FileHandler.WriteFile(scriptPath, []byte(scriptContent), 0644); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error writing batch script: %w", err)
        }</span>

        <span class="cov0" title="0">cmd := u.CommandRunner("cmd", "/C", "start", "/MIN", scriptPath)
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error starting batch script: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Update scheduled. The CLI will be updated after it exits.")
        return nil</span>
}

func (u *Updater) moveToExecutablePath(src string) error <span class="cov8" title="1">{
        executablePath := u.GetExecPath()
        return u.FileHandler.Rename(src, executablePath)
}</span>

func defaultGetExecutablePath() string <span class="cov8" title="1">{
        path, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Could not determine executable path: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov8" title="1">return path</span>
}

func init() <span class="cov8" title="1">{
        UpdateCmd.Flags().StringVar(&amp;version, "version", "", "Specific version to update to (default is latest)")
}</span>

var version string
</pre>
		
		<pre class="file" id="file3" style="display: none">package version

import (
        "fmt"

        "github.com/spf13/cobra"
)

// version is set via ldflags
var version string

var VersionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print the version number of Hyphen",
        Long:  `All software has versions. This is Hyphen's`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if version == "" </span><span class="cov0" title="0">{
                        version = "unknown" // Default if not set by ldflags
                }</span>
                <span class="cov0" title="0">fmt.Printf("Hyphen Version %s\n", version)</span>
        },
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "github.com/BurntSushi/toml"
        "os"
        "path/filepath"
        "runtime"
)

type CredentialsConfig struct {
        Default Credentials `toml:"default"`
}

type Credentials struct {
        HyphenAccessToken string `toml:"hyphen_access_token"`
}

// Filepaths for credential storage
const (
        WindowsConfigPath = "Hyphen"
        UnixConfigPath    = ".hyphen"
        CredentialFile    = "credentials.toml"
)

type Environment interface {
        GetConfigDirectory() string
        EnsureDir(dirName string) error
        WriteFile(filename string, data []byte, perm os.FileMode) error
        ReadFile(path string) ([]byte, error)
        GetGOOS() string
}

type systemEnvironment struct{}

func (se *systemEnvironment) GetGOOS() string <span class="cov8" title="1">{
        return runtime.GOOS
}</span>

func (se *systemEnvironment) GetConfigDirectory() string <span class="cov8" title="1">{
        switch se.GetGOOS() </span>{
        case "windows":<span class="cov0" title="0">
                return filepath.Join(os.Getenv("APPDATA"), WindowsConfigPath)</span>
        default:<span class="cov8" title="1">
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error retrieving home directory:", err)
                        return ""
                }</span>
                <span class="cov8" title="1">return filepath.Join(home, UnixConfigPath)</span>
        }
}

func (se *systemEnvironment) EnsureDir(dirName string) error <span class="cov8" title="1">{
        if _, err := os.Stat(dirName); os.IsNotExist(err) </span><span class="cov0" title="0">{
                err := os.MkdirAll(dirName, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error creating directory: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (se *systemEnvironment) WriteFile(filename string, data []byte, perm os.FileMode) error <span class="cov8" title="1">{
        return os.WriteFile(filename, data, perm)
}</span>

func (se *systemEnvironment) ReadFile(path string) ([]byte, error) <span class="cov8" title="1">{
        return os.ReadFile(path)
}</span>

var Env Environment = &amp;systemEnvironment{}

// SaveCredentials stores credentials in a system-dependent location
func SaveCredentials(username, password string) <span class="cov8" title="1">{
        configDir := Env.GetConfigDirectory()
        if err := Env.EnsureDir(configDir); err != nil </span><span class="cov8" title="1">{
                fmt.Println(err)
                return
        }</span>

        <span class="cov8" title="1">credentialFilePath := filepath.Join(configDir, CredentialFile)
        credentialsContent := fmt.Sprintf("[default]\nhyphen_access_token=\"%s:%s\"", username, password)

        // Write the credentials to the file
        if err := Env.WriteFile(credentialFilePath, []byte(credentialsContent), 0644); err != nil </span><span class="cov8" title="1">{
                fmt.Println("Error writing credentials to file:", err)
                return
        }</span>

        <span class="cov8" title="1">fmt.Println("Credentials saved successfully to", credentialFilePath)</span>
}

// GetCredentials retrieves credentials from a configuration file
func GetCredentials() (CredentialsConfig, error) <span class="cov8" title="1">{
        configDir := Env.GetConfigDirectory()
        credentialFilePath := filepath.Join(configDir, CredentialFile)

        // Read file using Environment's ReadFile method
        data, err := Env.ReadFile(credentialFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return CredentialsConfig{}, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov8" title="1">var config CredentialsConfig
        if err := toml.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return CredentialsConfig{}, fmt.Errorf("failed to decode credentials: %w", err)
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import "github.com/Hyphen/cli/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
